\documentclass[12pt,twoside]{article}
\usepackage{amsmath, amssymb}
\usepackage{amsmath}
\usepackage[active]{srcltx}
\usepackage{amssymb}
\usepackage{amscd}
\usepackage{makeidx}
\usepackage{amsthm}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{graphics}
%----------------------------------------------------------------------------------------------
\usepackage{amsmath, amssymb}
\usepackage{amsmath}
\usepackage[active]{srcltx}
\usepackage{amssymb}
\usepackage{amscd}
\usepackage{makeidx}
\usepackage[dvips]{graphicx}
\usepackage{booktabs,array,arydshln}
\usepackage[export]{adjustbox}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{siunitx}
\usepackage{etoolbox}
\usepackage[backend=biber]{biblatex}
\addbibresource{bibliografia.bib}

\renewcommand{\baselinestretch}{1}
\setcounter{page}{1}
\setlength{\textheight}{21.6cm}
\setlength{\textwidth}{14cm}
\setlength{\oddsidemargin}{1cm}
\setlength{\evensidemargin}{1cm}
\pagestyle{myheadings}
\thispagestyle{empty}
\markboth{\small{Pr\'actica 3. Catonga Tecla Daniel Isaí 1, Olguin Castillo Victor Manuel 2.}}{\small{.}}
\date{}
\begin{document}



\begin{figure}[h]
\vspace{-3cm} \hspace{-2cm} \setlength{\unitlength}{1mm}
\begin{picture}(15,25)(-10,0)
\includegraphics[width=16cm,height=3cm]{titulo.jpg}
\end{picture}
\end{figure}


\vspace{0cm}

\centerline{\bf Ingeniería en Inteligencia Artificial, An\'alisis y Diseño de Algoritmos}

\centerline{\bf Sem: 2024-1, 3BV1, Pr\'actica 3, 18 de octubre de 2023}

\centerline{}

%\centerline{}


\begin{center}
\Large{\textsc{Pr\'actica 3: Funciones Recursivas vs Iterativas.}}
\end{center}
\centerline{}
\centerline{\bf {Catonga Tecla Daniel Isaí 1, Olguin Castillo Victor Manuel 2.}}
\centerline{}
\centerline{$daniel9513importantes@gmail.com_1, manuelevansipn@gmail.com_2$}



\newtheorem{Theorem}{\quad Theorem}[section]

\newtheorem{Definition}[Theorem]{\quad Definition}

\newtheorem{Corollary}[Theorem]{\quad Corollary}

\newtheorem{Lemma}[Theorem]{\quad Lemma}

\newtheorem{Example}[Theorem]{\quad Example}

\bigskip

\textbf{Resumen:}\\





{\bf Palabras Clave:} Algoritmo, Big O, C++, Recursividad

%----------------------------------------------- INTRODUCCIÓN
\newpage
\section{Introducci\'on}
Texto ejemplo \cite{fibo}. 
\par

\newpage


\newpage
\section{Conceptos Basicos}

\begin{itemize}
\item \textbf{Algoritmo}. Un algoritmo es una secuencia de pasos lógicos que son precisos, ordenados y finitos que se ocupan para resolver un problema deseado\cite{concep1}.

\item \textbf{Análisis de  algoritmos}
Es un proceso de evaluación donde conoceremos el rendimiento y la eficiencia de un algoritmo. Se evaluará el consumo de tiempo y de recursos computacionales que requiere el algoritmo para ser ejecutado con diversos datos de entrada, y esto determinará su complejidad\cite{concep1}.

\item \textbf{Cota superior asintótica}. Es una función que delimita por la parte superior a otra función a medida que la entrada de la función delimitada crece.

\item \textbf{Cota inferior asintótica}. Es una función que delimita por la parte inferior a otra función a medida que la entrada de la función delimitada crece.

\item \textbf{Notacion O}. Esta notación se ocupa para describir la complejidad de un algoritmo definiendo una cota superior asintótica en el peor caso de ejecución de un algoritmo\cite{concep1}.
\\
\[O(g(n)) = \{ f : \mathbb{N} \rightarrow \mathbb{R}^+ \ | \ \exists \ c \text{ constante positiva y } n_0 \notin \mathbb{N} :\] 
\[f(n) \leq cg(n), \ \forall \ n \geq n_0 \}\]

\item \textbf{Notacion Tetha "$\Theta$"} Esta notación se ocupa para describir la complejidad de un algoritmo definiendo una cota superior y una cota inferior, esto nos da una idea más precisa del comportamiento y complejidad del mismo\cite{concep1}.
\\
\[\Theta(g(n) = \{f : \mathbb{N} \rightarrow \mathbb{R}^+ \,|\, \exists \, c_1, c_2 \text{ constantes positivas}, n_0 \,: \]
\[0 < c_1g(n) \leq f(n) \leq c_2g(n), \forall \, n \geq n_0\}\]

\item \textbf{Notacion Omega "$\Omega$"}  Esta notación se ocupa para describir la complejidad de un algoritmo definiendo una cota inferior asintótica en el peor caso de ejecución de un algoritmo\cite{concep1}.
\\
\[\Omega(g(n)) = \{f : \mathbb{N} \rightarrow \mathbb{R}^+ \,|\, \exists \, c \text{ constante positiva y } n_0 \,:\]
\[0 < cg(n) \leq f(n), \forall \, n \geq n_0\}\]


\item \textbf{Analisis a posteriori}. Es una evaluación que se realiza de forma empírica, donde los resultados se obtienen con la ejecución del algoritmo y la medición del tiempo y recursos computacionales que requiere\cite{concep1}.

\item \textbf{Analisis a priori}. Es una evaluacion que se realiza de forma teorica, donde los resultados se pueden obtener con el conteo de operaciones y/o analisis matematico que en base a sus formulas se obtiene su complegidad algoritmica\cite{concep1}.


\item \textbf{Sucesion de Fibonacci}. Es una secuencia matematica infinita que incia con los numeros 0 y 1, y el numero siguiente sera la suma de los dos numeros anteriores a este\cite{fibo}.\\

\centerline{El tercer número es 0 + 1 = 1.}
\centerline{El cuarto número es 1 + 1 = 2.}
\centerline{El quinto número es 1 + 2 = 3.}

\item \textbf{Numero perfecto}.Se le considera numero perfecto a aquel que la suma de sus divisores propios positivos da por por resultado el mismo numero\cite{key}.\\

\centerline{Los divisores positivos de 28 son 1, 2, 4, 7 y 14.}
\centerline{Si sumamos estos divisores: 1 + 2 + 4 + 7 + 14 = 28.}

\item \textbf{Funciones recursivas}. En la programacion las funciones recursivas son aquellas que durante su proceso se invocan asi mismas.

\begin{centering}
\begin{verbatim}
                    Suma_Recursiva(n):
                    If n == 1
                        return 1 
                    Else
                        return n + sumaRecursiva(n - 1)
\end{verbatim}
\end{centering}

\item \textbf{Funciones iterativas}. En la programacion las funciones iterativas son aquellas se ejecuta en un ciclo n numero de veces y existe una condicion de validacion en cada iteracion que controla si se itera una ves mas o finaliza en ciclo

\begin{centering}
\begin{verbatim}
                    Suma_iterativa(n):
                    resultado = 0
                    for i = 0 to n do:
                        resultado += i
                    return resultado
\end{verbatim}
\end{centering}
\newpage

\item \textbf{Pseudocodigo Sucesion de Fibonacci version iterativa}\\

\begin{centering}
\begin{verbatim}
fibonacci_iterativa(num_anterior, num_actual, n)
for i = 0 to n do
    print num_actual
    aux = num_actual;
    num_actual += num_anterior;
    num_anterior = aux;


\end{verbatim}
\end{centering}

\item \textbf{Pseudocodigo Sucesion de Fibonacci version recursiva}

\begin{centering}
\begin{verbatim}
fibonacci_recursiva(num_anterior, num_actual, n)
    if n == 0
        return
    else
        print num_actual
        fibonacci_recursiva(num_actual, num_actual + num_anterior, n-1); 

\end{verbatim}
\end{centering}

\item \textbf{Pseudocódigo Perfecto}.
El algoritmo de Perfecto dice si el número n es perfecto o no, haciendo la suma de sus divisores con un for, retorna un 0 si el número no es perfecto y retorna un 1 si es perfecto.
\begin{center}
\begin{verbatim}
                    Perfecto(n):
                    contador = 0
                    for i = 1 to i = n-1 do
                      if n%i == 0
                        contador = contador + i
                    if contador == n
                      retorna 1
                    retorna 0
\end{verbatim}
\end{center}
\newpage
\item \textbf{Pseudocódigo MostrarPerfectos}.
El algoritmo de MostrarPerfectos, muestra n números perfectos, para cuando $n=2$ muestra dos números perfectos tal que el output es: [$6,28$]. Utiliza la función Perfecto para calcular los números perfectos.
\begin{center}
\begin{verbatim}
                    MostrarPerfectos(n):
                    contador = 0
                    for i = 1 to contador != n do
                      if Perfecto(i) do
                        imprime i
                        contador = contador + i 
\end{verbatim}
\end{center}

\end{itemize}
\newpage
%------------------------------------------- EXPERIMENTACIÓN Y RESULTADOS
\section{Experimentación y Resultados}

\newpage
\section{Conclusiones}

Texto ejemplo, conclusión general.
\medskip

Conclusiones Catonga Tecla Daniel Isaí 1
\par
Texto ejemplo.

\medskip

Conclusiones Olguin Castillo Victor Manuel 2
\par
Texto ejemplo.

\newpage
\section{Bibliograf\'ia}

Ejemplo de referencias.
\printbibliography[title={ }]










\end{document}
